---
import type { MarkdownHeading } from 'astro'

export type Props = {
	headings: MarkdownHeading[]
}

const { headings } = Astro.props

const items = headings.filter((el) => el.depth > 1 && el.depth <= 3)
---

<nav class="sticky top-[var(--header-height)] h-full">
	<strong class="text-lg font-bold">On this page</strong>
	<c-toc class="contents">
		<ul>
			{
				items.map((item) => (
					<li
						style={{
							'padding-inline-start': `${(item.depth - 2) * 0.5}rem`,
						}}
					>
						<a
							href={'#' + item.slug}
							class="hover:text-accent data-current:text-accent text-gray-600 dark:text-gray-300"
						>
							{item.text}
						</a>
					</li>
				))
			}
		</ul>
	</c-toc>
</nav>

<script>
	class Toc extends HTMLElement {
		#links: NodeListOf<HTMLAnchorElement>
		#headings: NodeListOf<HTMLHeadingElement>
		#observer: IntersectionObserver

		constructor() {
			super()
			this.#links = this.querySelectorAll('a')
			this.#headings = document.querySelectorAll('.prose>h2,.prose>h3')
			this.#observer = new IntersectionObserver(this.#observerCallback, {
				// Negative bottom margin means heading needs to be towards top of viewport to trigger intersection.
				rootMargin: '10% 0% -70%',
			})
		}

		connectedCallback() {
			this.#headings.forEach((el) => this.#observer.observe(el))
		}

		disconnectedCallback() {
			this.#headings.forEach((el) => this.#observer.unobserve(el))
		}

		#observerCallback: IntersectionObserverCallback = (entries) => {
			for (const { isIntersecting, target } of entries) {
				if (isIntersecting) {
					this.#links.forEach((el) => {
						if (el.href.endsWith('#' + target.id))
							el.setAttribute('data-current', 'true')
						else el.removeAttribute('data-current')
					})
					break
				}
			}
		}
	}

	customElements.define('c-toc', Toc)
</script>
